2012.09.12 Wed.

xy., .ybu, alabam.bu 等が使えるようにする。
da, de, di, do と同様の扱いとする。
これらを結果にどう表示しようか。
da du la hoger..i de du la hager.
といった感じか。

その前に package 化してしまおうかな。

2012.09.13 Thu.

PrologLike な部分をもっと本質的なところから書き換えたい。
変数、定数、事実、ルール等。

静的スコープとするために、アルファ変換が必要だ。
あるいは、スコープ名による修飾が必要。

けっこう大変だ。
一度単純化したモデルを作ってからのほうが良さそう。

きちんとした理論を作ってからのほうが良い気がする。
主に unification という問題だ。

unification について。
f(x) = g(y) という unification は
[f, x] = [g, y] という unification と考えることができる。

Unification.hs の deleteElem はいらないかもしれないが、
今のところ単純に考えられるようにいれておく。
コードを整理する際に消すかもしれない。

merge を作る。
同じ X, Y 等があったら value を比較してひとつにする。
無ければそのまま追加。

not を実装するのが思った以上に難しい。
単純に unification できなければ良いというわけではない。
もちろん unification できなかった場合には問題なく、Just とできる。
また unification できて、変数が残らなかった場合にも問題なく Nothing とできる。
しかし、unification できた場合で、変数が残った場合、
変数の組み合わせによっては not が true となる組み合わせも存在する。
しかも、ある unification の片方の辺のみを not とするわけだ。
これはなかなか難しい。

つまり、これは他の unification が全て終わったあとで、
それらを適用したうえで、not のかかっている辺が矛盾するような組み合わせのみを
残すということだ。
つまり、ある Fact つまり [Term] に対して、
Result を適用する関数をまずは使る必要がある。
たとえば、(X, Y) が残った場合には not は true となる。
つまり不定の2つは true にも false にもできる。
(X, hoge) が残った場合も同様だ。

(x, Y, Z) と not (x, B, C) を unification することを考える。

たとえば du(X, X) において not du(Y, Z) とは
(du, X, X) と (du, Y, Z) が unification できないということだ。
つまり、Y と Z に違うものが入り得る場合、これは go'i となる。
となると、(x, Y, Z) と (x, B, C) は unification できない状態とならないので、
nago'i となるのか。
いくつかの rule があった場合にはどうか。
複数の rule があった場合には肯定の場合には or 接続ということになる。
ということは否定の場合にはどれかひとつでも成り立ったらだめということだ。
全てとの unification で Nothing となるような (x, B, C) の組み合わせがあれば、
OK ということになる。

つまり、最初の項だけは match しなくてはならない。
残りの項については、どれかひとつでも、あるいは互いにでも良いので、
何かしら match しない値が選べれば良い。
最初の項が match する fact との unification を全て行い、
そのどれとでも unification できない値を選び得るかどうかを見る。

2012.09.14 Fri.

たとえば、(A, B, C) と (X, Y, Z) が unification できないとは、
A /= X || B /= Y || C /= Z ということだ。
これを表現しなくてはならない。
つまり、(A, B, C) not match (X, Y, Z) かつ (D, E) not match (W, V) は、
[[(A, X), (B, Y), (C, Z)], [(D, w), (E, V)]]
と表せる。

unification できない状態。
unification できないと確定した状態。
unification できない可能性のある状態。
unification できると確定した状態。

項があるのに Just [] となったら unification できないと確定。

not の check はできそう。
そしたら、次にすることは、すべての rule と unification した結果のすべてにおいて、
check が通ることを確かめることだ。
